"""
Pydantic schemas for Sahtein 3.0
All data models used throughout the application
"""

from datetime import datetime
from typing import Literal, Optional
from pydantic import BaseModel, Field, HttpUrl, ConfigDict


# ============================================================================
# Data Models - Base 1 (OLJ Articles)
# ============================================================================

class ArticleEnrichment(BaseModel):
    """Enriched metadata generated by LLM for OLJ articles."""
    content_type: Literal["recipe", "cultural", "portrait", "technique"] = "recipe"
    is_recipe: bool = True
    is_lebanese: bool = True
    cuisine_type: str = "libanaise"
    category: str = "plat_principal"
    dietary_tags: list[str] = Field(default_factory=list)
    contains_meat: bool = False
    contains_dairy: bool = False
    contains_gluten: bool = True
    difficulty: str = "moyen"
    prep_time_minutes: int | str | None = None  # Can be "inconnu"
    servings: int | str | None = None  # Can be "inconnu"
    chef_name: str | None = None
    dish_canonical_name: str = ""
    aliases: list[str] = Field(default_factory=list)
    main_ingredients: list[str] = Field(default_factory=list)
    teaser: str = ""

    def matches_dietary(self, requirements: list[str]) -> bool:
        """Vérifie si l'article correspond aux exigences alimentaires."""
        for req in requirements:
            if req == "vegetarien" and self.contains_meat:
                return False
            if req == "vegan" and (self.contains_meat or self.contains_dairy):
                return False
            if req == "sans_gluten" and self.contains_gluten:
                return False
            if req == "sans_lactose" and self.contains_dairy:
                return False
        return True


class RecipeArticle(BaseModel):
    """OLJ recipe article from Base 1"""

    article_id: str
    title: str
    normalized_title: str
    slug: str
    url: str
    chef: str | None = None
    author: str | None = None
    section: str = "Liban à table"
    tags: list[str] = Field(default_factory=list)
    publish_date: datetime | None = None
    modified_date: datetime | None = None
    popularity_score: float = 0.0
    short_summary: str = ""
    description: str = ""
    anecdote: str = ""
    tips: list[str] = Field(default_factory=list)

    # For link resolution
    is_editor_pick: bool = False
    ingredients: list[str] = Field(default_factory=list)
    instructions: list[str] = Field(default_factory=list)
    dish_name: str | None = None
    course: str | None = None
    diet: str | None = None
    main_ingredients: list[str] = Field(default_factory=list)
    cuisine: str | None = None
    editorial_score: float = 0.0
    recency_score: float = 0.0
    image_url: str | None = None
    doc_text: str = ""
    is_recipe: bool = True

    # New enrichment field (optional)
    enrichment: Optional[ArticleEnrichment] = None

# Alias for backward compatibility and semantic clarity in new code
OLJArticle = RecipeArticle

# ============================================================================
# Data Models - Base 2 (Structured Recipes)
# ============================================================================

class Ingredient(BaseModel):
    """Structured ingredient with quantity"""

    nom: str
    quantite: float | int | None = None
    unite: str | None = None

    def to_text(self) -> str:
        """Convert to human-readable text"""
        if self.quantite and self.unite:
            return f"{self.quantite} {self.unite} de {self.nom}"
        elif self.quantite:
            return f"{self.quantite} {self.nom}"
        else:
            return self.nom


class StructuredRecipe(BaseModel):
    """Structured recipe from Base 2"""

    recipe_id: str
    name: str
    normalized_name: str
    category: str = ""
    ingredients: list[Ingredient]
    steps: list[str] = Field(alias="etapes", default_factory=list)
    servings: int | None = Field(alias="nombre_de_personnes", default=None)
    prep_time: str | None = Field(alias="temps_preparation", default=None)
    cook_time: str | None = Field(alias="temps_cuisson", default=None)
    difficulty: str | None = Field(alias="difficulte", default=None)
    tags: list[str] = Field(default_factory=list)

    model_config = ConfigDict(populate_by_name=True)

# Alias for semantic clarity
Base2Recipe = StructuredRecipe

# ============================================================================
# Data Models - Golden Examples
# ============================================================================

class GoldenExample(BaseModel):
    """Golden example from test dataset"""

    id: str
    scenario: str
    title: str
    user_query: str
    response: str
    expected_intent: str | None = None
    expected_url: str | None = None
    metadata: dict = Field(default_factory=dict)


# ============================================================================
# RAG Pipeline Models
# ============================================================================

class SearchResult(BaseModel):
    """Unified search result."""
    id: str
    url: str
    title: str
    source: Literal["olj", "base2"]
    
    # Scores
    bm25_score: float = 0.0
    embedding_score: float = 0.0
    final_score: float = 0.0
    
    # Metadata (from enrichment for OLJ)
    content_type: str = "recipe"
    is_recipe: bool = True
    is_lebanese: bool = True
    category: str = ""
    dietary_tags: list[str] = Field(default_factory=list)
    chef_name: str | None = None
    teaser: str = ""
    
    # Full data (for Base2)
    ingredients: list[Ingredient] | None = None
    steps: list[str] | None = None


class ClassificationResult(BaseModel):
    """Result from ClassifierAgent"""

    intent: Literal[
        "recipe_by_name",
        "recipe_by_ingredients",
        "idea_by_ingredients",
        "menu_planning",
        "menu_request",
        "food_chat",
        "accompaniment_request",
        "small_talk",
        "greeting",
        "farewell",
        "about_bot",
        "non_french",
        "anti_injection",
        "off_topic",
        "foreign_cuisine",
        "frustration",
    ]
    language: Literal["fr", "non_fr"]
    confidence: float = 1.0
    slots: dict[str, list[str]] = Field(default_factory=dict)
    quantity_hint: Literal[1, 3] = 1
    primary_dish: str | None = None
    requires_base2: bool = False
    is_continuation: bool = False
    is_priority_rule: bool = False
    enriched_query: str | None = None
    continuation_modifiers: list[str] = Field(default_factory=list)
    # slots structure:
    # - dishes: list[str]
    # - ingredients: list[str]
    # - methods: list[str]  (e.g., "au four", "salade", "dessert")
    # - occasions: list[str]  (e.g., "mezze", "dinner")


class QueryPlan(BaseModel):
    """Query understanding and retrieval plan"""

    need_type: Literal[
        "recipe_by_ingredients",
        "recipe_by_name",
        "idea_by_ingredients",
        "menu_planning",
        "menu_request",
        "accompaniment_request",
        "frustration",
        "food_chat",
        "small_talk",
        "suggestions",
        "off_topic",
        "greeting",
        "about_bot"
    ]
    primary_dish: str | None = None
    ingredients: list[str] = Field(default_factory=list)
    constraints: list[str] = Field(default_factory=list)
    language: Literal["fr", "non_fr"]
    retrieval_query: str
    link_query: str | None = None
    quantity_hint: Literal[1, 3] = 1
    max_results: int = 1
    allow_base2: bool = False
    prefer_base2: bool = False


class RetrievalCandidate(BaseModel):
    """A single retrieval candidate"""

    source: Literal["olj", "base2"]
    content: str
    score: float
    metadata: dict = Field(default_factory=dict)

    # For OLJ candidates
    article_id: str | None = None

    # For Base 2 candidates
    recipe_id: str | None = None


class LinkResolutionResult(BaseModel):
    """Result from LinkResolver"""

    primary_article: RecipeArticle | None = None
    suggested_articles: list[RecipeArticle] = Field(default_factory=list)
    strategy: str = "none"  # e.g., "exact_match", "similarity", "fallback"
    confidence: float = 0.0
    no_match: bool = False
    source: Literal["olj", "base2", "mixed"] = "olj"
    primary_url: str | None = None
    suggested_urls: list[str] = Field(default_factory=list)


class ValidationResult(BaseModel):
    """Validation result from ContentGuard"""

    is_valid: bool = True
    errors: list[str] = Field(default_factory=list)
    warnings: list[str] = Field(default_factory=list)
    corrected_html: str | None = None


class ScenarioContext(BaseModel):
    """Context for scenario selection"""

    scenario_id: int
    scenario_name: str
    use_base: Literal["olj", "base2", "mixed", "none"]
    show_full_recipe: bool = False  # True only for Base 2 scenarios
    include_link: bool = True


class ChatResponse(BaseModel):
    """Final response to user"""

    html: str
    scenario_id: int
    scenario_name: str
    used_base: Literal["olj", "base2", "mixed", "none"]
    primary_url: str | None = None
    debug_info: dict = Field(default_factory=dict)


# ============================================================================
# API Models
# ============================================================================

class ChatRequest(BaseModel):
    """API request for chat endpoint"""

    message: str = Field(..., min_length=1, max_length=500)
    conversation_id: str | None = None
    debug: bool = False


class ChatResponseAPI(BaseModel):
    """API response for chat endpoint"""

    html: str
    scenario_id: int | None = None
    scenario_name: str | None = None
    primary_url: str | None = None
    debug_info: dict | None = None


# ============================================================================
# Index Models (for retrieval)
# ============================================================================

class ContentDocument(BaseModel):
    """Document in content index"""

    doc_id: str
    source: Literal["olj", "base2"]
    content: str
    metadata: dict = Field(default_factory=dict)


class LinkDocument(BaseModel):
    """Document in link index (article-level only)"""

    article: RecipeArticle
    searchable_text: str  # Combined normalized_title + tags + chef


class AgentState(BaseModel):
    """Minimal state tracking for the Agent Orchestrator"""
    history: list[dict] = Field(default_factory=list)
    last_recipe_url: str | None = None
